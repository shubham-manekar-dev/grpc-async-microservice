#!/usr/bin/env bash
set -euo pipefail

if ! PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"; then
  echo "Unable to determine project root" >&2
  exit 1
fi
cd "$PROJECT_ROOT" || exit 1

STEP=0

step() {
  STEP=$((STEP + 1))
  printf '\n==== Step %d: %s ====\n' "${STEP}" "$1"
}

info() {
  printf '     %s\n' "$1"
}

warn() {
  printf '⚠️  %s\n' "$1"
}

fail() {
  printf '❌ %s\n' "$1" >&2
  exit 1
}

# Determine Docker Compose command (prefer v2 syntax)
DOCKER_COMPOSE_CMD=()
DOCKER_COMPOSE_LABEL=""
if docker compose version >/dev/null 2>&1; then
  DOCKER_COMPOSE_CMD=(docker compose)
  DOCKER_COMPOSE_LABEL="docker compose"
elif command -v docker-compose >/dev/null 2>&1; then
  DOCKER_COMPOSE_CMD=(docker-compose)
  DOCKER_COMPOSE_LABEL="docker-compose"
else
  fail "Docker Compose v2 (docker compose) or v1 (docker-compose) is required."
fi

REQUIRED_CMDS=("docker" "curl")
if [[ "$DOCKER_COMPOSE_LABEL" == "docker-compose" ]]; then
  REQUIRED_CMDS+=("docker-compose")
fi
MISSING=()

for cmd in "${REQUIRED_CMDS[@]}"; do
  if ! command -v "$cmd" >/dev/null 2>&1; then
    MISSING+=("$cmd")
  fi
done

if ((${#MISSING[@]} > 0)); then
  fail "Missing required tooling: ${MISSING[*]}. Install the dependencies and rerun the script."
fi

OPTIONAL_CMDS=(
  "make:Used for local CI parity (make ci)"
  "python3:Needed for backend tooling and smoke checks"
  "npm:Required for frontend development outside Docker"
  "mvn:Executes the TestNG RAML suite"
  "shellcheck:Lint helper scripts like this one"
)

step "Checking optional tooling"
for entry in "${OPTIONAL_CMDS[@]}"; do
  cmd="${entry%%:*}"
  message="${entry#*:}"
  if command -v "$cmd" >/dev/null 2>&1; then
    info "Found ${cmd}"
  else
    warn "${cmd} not detected. ${message}"
  fi
done

ENV_FILE="$PROJECT_ROOT/.env"
if [[ ! -f "$ENV_FILE" ]]; then
  step "Seeding optional .env (heuristic defaults)"
  cat <<'ENV' > "$ENV_FILE"
# Generated by scripts/start_project.sh
# Uncomment and fill these values to enable hosted generative AI providers.
# GEN_AI_PROVIDER=openai
# GEN_AI_API_KEY=sk-...
# GEN_AI_MODEL=gpt-4o-mini
# GEN_AI_PROVIDER=gemini
# GEN_AI_API_KEY=your-gemini-key
# GEN_AI_MODEL=gemini-pro
ENV
  info "Created .env with heuristic defaults."
else
  step "Reusing existing .env"
  info "Loaded environment overrides from .env"
fi

step "Building and starting Docker services"
"${DOCKER_COMPOSE_CMD[@]}" up --build -d
"${DOCKER_COMPOSE_CMD[@]}" ps

wait_for_endpoint() {
  local url="$1"
  local description="$2"
  local attempts=${3:-60}
  local delay=${4:-2}

  local compose_hint="${DOCKER_COMPOSE_CMD[*]} logs backend"
  local -i attempt=1
  local -i max_attempts
  max_attempts=$attempts

  while (( attempt <= max_attempts )); do
    if curl --fail --silent "$url" >/dev/null 2>&1; then
      info "${description} is ready (${url})"
      return 0
    fi
    sleep "$delay"
    attempt=$((attempt + 1))
  done

  fail "Timed out waiting for ${description} at ${url}. Use '${compose_hint}' for details."
}

step "Waiting for FastAPI health checks"
wait_for_endpoint "http://localhost:8000/health" "FastAPI /health"
wait_for_endpoint "http://localhost:8000/integrations" "Integration readiness"

step "Project ready"
info "Backend API:       http://localhost:8000/docs"
info "Recruiter Console: http://localhost:5173"
info "Prometheus:        http://localhost:9090"
info "Grafana:           http://localhost:3000 (admin / admin)"
info "Kibana:            http://localhost:5601"
info "Kafka broker:      localhost:9092"
info "Postgres:          localhost:5432 (care_admin / care_password)"
info "MongoDB:           localhost:27017"
info "Redis:             localhost:6379"

STOP_STACK_CMD="${DOCKER_COMPOSE_CMD[*]} down"
printf '\nWhen you are finished, run "%s" to stop the stack.\n' "$STOP_STACK_CMD"
